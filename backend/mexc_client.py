#!/usr/bin/env python3
"""
MEXC API Client —Å –¥–µ–º–æ-—Ä–µ–∂–∏–º–æ–º –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ–≥–æ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
"""
import os
import time
import hmac
import hashlib
import requests
import json
from typing import Dict, List, Optional
from datetime import datetime
from dotenv import load_dotenv

load_dotenv()

class MEXCDemoAccount:
    """–í–∏—Ä—Ç—É–∞–ª—å–Ω—ã–π –¥–µ–º–æ-—Å—á—ë—Ç –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –±–µ–∑ —Ä–∏—Å–∫–∞"""
    
    MAKER_FEE = 0.0002  # 0.02% maker fee (MEXC)
    TAKER_FEE = 0.0006  # 0.06% taker fee (MEXC)
    
    def __init__(self, initial_balance_usdt: float = 10000):
        self.balance = {
            'USDT': initial_balance_usdt,
        }
        self.positions = {}  # {symbol: {amount, avg_price, side}}
        self.orders = []  # –ò—Å—Ç–æ—Ä–∏—è –æ—Ä–¥–µ—Ä–æ–≤
        self.trades = []  # –ò—Å—Ç–æ—Ä–∏—è —Å–¥–µ–ª–æ–∫
        self.order_id_counter = 1
        self.total_fees_paid = 0  # –û—Ç—Å–ª–µ–∂–∏–≤–∞–µ–º –∫–æ–º–∏—Å—Å–∏–∏
        
    def get_balance(self) -> Dict:
        return self.balance.copy()
    
    def place_order(self, symbol: str, side: str, order_type: str, 
                    quantity: float, price: Optional[float] = None) -> Dict:
        """–≠–º—É–ª—è—Ü–∏—è —Ä–∞–∑–º–µ—â–µ–Ω–∏—è –æ—Ä–¥–µ—Ä–∞"""
        order = {
            'orderId': f'DEMO_{self.order_id_counter}',
            'symbol': symbol,
            'side': side,  # BUY / SELL
            'type': order_type,  # LIMIT / MARKET
            'quantity': quantity,
            'price': price,
            'status': 'FILLED',  # –î–ª—è –¥–µ–º–æ —Å—Ä–∞–∑—É –∏—Å–ø–æ–ª–Ω—è–µ–º
            'timestamp': int(time.time() * 1000),
        }
        self.order_id_counter += 1
        self.orders.append(order)
        
        # –≠–º—É–ª–∏—Ä—É–µ–º –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ
        self._execute_order(order)
        
        return order
    
    def _execute_order(self, order: Dict):
        """–ò—Å–ø–æ–ª–Ω–µ–Ω–∏–µ –æ—Ä–¥–µ—Ä–∞ ‚Äî –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–∞ –∏ –ø–æ–∑–∏—Ü–∏–π"""
        symbol = order['symbol']
        side = order['side']
        quantity = order['quantity']
        price = order['price']
        order_type = order.get('type', 'MARKET')
        
        base_asset = symbol.replace('USDT', '')
        
        if side == 'BUY':
            cost = quantity * price
            fee = cost * (self.TAKER_FEE if order_type == 'MARKET' else self.MAKER_FEE)
            total_cost = cost + fee
            
            if self.balance.get('USDT', 0) >= total_cost:
                self.balance['USDT'] -= total_cost
                self.balance[base_asset] = self.balance.get(base_asset, 0) + quantity
                self.total_fees_paid += fee
                
                trade = {
                    'symbol': symbol,
                    'side': side,
                    'quantity': quantity,
                    'price': price,
                    'cost': cost,
                    'fee': fee,
                    'timestamp': order['timestamp'],
                }
                self.trades.append(trade)
            else:
                order['status'] = 'REJECTED'
                order['error'] = 'Insufficient balance'
        
        elif side == 'SELL':
            if self.balance.get(base_asset, 0) >= quantity:
                self.balance[base_asset] -= quantity
                proceeds = quantity * price
                fee = proceeds * (self.TAKER_FEE if order_type == 'MARKET' else self.MAKER_FEE)
                net_proceeds = proceeds - fee
                self.balance['USDT'] = self.balance.get('USDT', 0) + net_proceeds
                self.total_fees_paid += fee
                
                trade = {
                    'symbol': symbol,
                    'side': side,
                    'quantity': quantity,
                    'price': price,
                    'proceeds': proceeds,
                    'fee': fee,
                    'net_proceeds': net_proceeds,
                    'timestamp': order['timestamp'],
                }
                self.trades.append(trade)
            else:
                order['status'] = 'REJECTED'
                order['error'] = 'Insufficient asset balance'
    
    def get_trades(self) -> List[Dict]:
        return self.trades.copy()


class MEXCClient:
    """MEXC API Client —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –¥–µ–º–æ-—Ä–µ–∂–∏–º–∞"""
    
    BASE_URL = 'https://api.mexc.com'
    FUTURES_URL = 'https://futures.mexc.com/api/v1'
    
    def __init__(self, api_key: str, secret_key: str, demo_mode: bool = True, use_futures: bool = True):
        self.api_key = api_key
        self.secret_key = secret_key
        self.demo_mode = demo_mode
        self.use_futures = use_futures
        
        if demo_mode:
            initial_balance = float(os.getenv('DEMO_BALANCE_USDT', 10000))
            self.demo_account = MEXCDemoAccount(initial_balance)
            print(f"üéÆ DEMO MODE –∞–∫—Ç–∏–≤–µ–Ω. –í–∏—Ä—Ç—É–∞–ª—å–Ω—ã–π –±–∞–ª–∞–Ω—Å: {initial_balance} USDT")
        else:
            self.demo_account = None
            print("‚ö†Ô∏è  REAL MODE –∞–∫—Ç–∏–≤–µ–Ω!")
    
    def _sign(self, params: Dict) -> str:
        """–ü–æ–¥–ø–∏—Å—å –∑–∞–ø—Ä–æ—Å–∞"""
        query_string = '&'.join([f"{k}={v}" for k, v in sorted(params.items())])
        signature = hmac.new(
            self.secret_key.encode('utf-8'),
            query_string.encode('utf-8'),
            hashlib.sha256
        ).hexdigest()
        return signature
    
    def get_ticker_price(self, symbol: str) -> float:
        """–ü–æ–ª—É—á–∏—Ç—å —Ç–µ–∫—É—â—É—é —Ü–µ–Ω—É (—Ä–µ–∞–ª—å–Ω–∞—è, –Ω–µ –¥–µ–º–æ)"""
        url = f"{self.BASE_URL}/api/v3/ticker/price"
        params = {'symbol': symbol}
        
        response = requests.get(url, params=params)
        response.raise_for_status()
        data = response.json()
        
        return float(data['price'])
    
    def get_klines(self, symbol: str, interval: str = '1m', limit: int = 100) -> List:
        """–ü–æ–ª—É—á–∏—Ç—å —Å–≤–µ—á–∏ (—Ä–µ–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ)"""
        url = f"{self.BASE_URL}/api/v3/klines"
        params = {
            'symbol': symbol,
            'interval': interval,
            'limit': limit,
        }
        
        response = requests.get(url, params=params)
        response.raise_for_status()
        
        return response.json()
    
    def get_balance(self) -> Dict:
        """–ü–æ–ª—É—á–∏—Ç—å –±–∞–ª–∞–Ω—Å"""
        if self.demo_mode:
            return self.demo_account.get_balance()
        
        # TODO: –†–µ–∞–ª—å–Ω—ã–π API –∑–∞–ø—Ä–æ—Å (—Ç—Ä–µ–±—É–µ—Ç –ø–æ–¥–ø–∏—Å–∏)
        # –ü–æ–∫–∞ –Ω–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–æ –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
        raise NotImplementedError("Real balance API not implemented yet")
    
    def place_order(self, symbol: str, side: str, order_type: str, 
                    quantity: float, price: Optional[float] = None) -> Dict:
        """–†–∞–∑–º–µ—Å—Ç–∏—Ç—å –æ—Ä–¥–µ—Ä"""
        if self.demo_mode:
            # –í –¥–µ–º–æ-—Ä–µ–∂–∏–º–µ –±–µ—Ä—ë–º —Ç–µ–∫—É—â—É—é —Ä—ã–Ω–æ—á–Ω—É—é —Ü–µ–Ω—É
            if price is None:
                price = self.get_ticker_price(symbol)
            
            return self.demo_account.place_order(symbol, side, order_type, quantity, price)
        
        # TODO: –†–µ–∞–ª—å–Ω—ã–π API –∑–∞–ø—Ä–æ—Å
        raise NotImplementedError("Real order API not implemented yet ‚Äî safety first")
    
    def get_trades(self) -> List[Dict]:
        """–ü–æ–ª—É—á–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é —Å–¥–µ–ª–æ–∫"""
        if self.demo_mode:
            return self.demo_account.get_trades()
        
        raise NotImplementedError("Real trades API not implemented yet")


def main():
    """–¢–µ—Å—Ç –∫–ª–∏–µ–Ω—Ç–∞"""
    client = MEXCClient(
        api_key=os.getenv('MEXC_API_KEY'),
        secret_key=os.getenv('MEXC_SECRET_KEY'),
        demo_mode=True
    )
    
    print("\n=== –¢–µ—Å—Ç MEXC Client ===\n")
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ü–µ–Ω—ã
    print("–ü–æ–ª—É—á–∞—é —Ç–µ–∫—É—â—É—é —Ü–µ–Ω—É BTC...")
    btc_price = client.get_ticker_price('BTCUSDT')
    print(f"BTC/USDT: ${btc_price:,.2f}")
    
    # –ë–∞–ª–∞–Ω—Å
    print("\n–ë–∞–ª–∞–Ω—Å:")
    balance = client.get_balance()
    print(json.dumps(balance, indent=2))
    
    # –¢–µ—Å—Ç–æ–≤–∞—è –ø–æ–∫—É–ø–∫–∞
    print(f"\n–ü–æ–∫—É–ø–∞—é 0.001 BTC –ø–æ —Ä—ã–Ω–∫—É (~${btc_price * 0.001:.2f})...")
    order = client.place_order('BTCUSDT', 'BUY', 'MARKET', 0.001)
    print(f"–û—Ä–¥–µ—Ä: {order['orderId']} ‚Äî {order['status']}")
    
    # –ë–∞–ª–∞–Ω—Å –ø–æ—Å–ª–µ –ø–æ–∫—É–ø–∫–∏
    print("\n–ë–∞–ª–∞–Ω—Å –ø–æ—Å–ª–µ –ø–æ–∫—É–ø–∫–∏:")
    balance = client.get_balance()
    print(json.dumps(balance, indent=2))
    
    # –ò—Å—Ç–æ—Ä–∏—è —Å–¥–µ–ª–æ–∫
    print("\n–ò—Å—Ç–æ—Ä–∏—è —Å–¥–µ–ª–æ–∫:")
    trades = client.get_trades()
    for trade in trades:
        print(f"  {trade['side']} {trade['quantity']} @ ${trade['price']:.2f}")

if __name__ == '__main__':
    main()
